{% extends "base.html" %}

{% block title %}Dashboard - Auto-Trader{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-md-12">
        <h1>Dashboard</h1>
        <p class="lead">Overview of your portfolio and trading activity</p>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-4">
        <div class="card shadow-sm h-100">
            <div class="card-body">
                <h5 class="card-title">Portfolio Value</h5>
                <h2 class="display-4 mb-0" id="account-value">$0.00</h2>
                <p class="text-muted" id="daily-change">0.00% today</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card shadow-sm h-100">
            <div class="card-body">
                <h5 class="card-title">Cash Balance</h5>
                <h2 class="display-4 mb-0" id="cash-balance">$0.00</h2>
                <p class="text-muted">Available for trading</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card shadow-sm h-100">
            <div class="card-body">
                <h5 class="card-title">Positions</h5>
                <h2 class="display-4 mb-0" id="positions-count">0</h2>
                <p class="text-muted">Active positions</p>
            </div>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-12">
        <div class="card shadow-sm">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Option Opportunities</h5>
                <div class="d-flex align-items-center">
                    <button class="btn btn-sm btn-outline-primary" id="refresh-all-options">
                        <i class="bi bi-arrow-repeat"></i> Refresh All
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Price</th>
                                <th>Position</th>
                                <th>OTM %</th>
                                <th>Sell Call</th>
                                <th>Call Premium</th>
                                <th>Sell Put</th>
                                <th>Put Premium</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="options-table">
                            <tr>
                                <td colspan="9" class="text-center">Loading options data...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="card-footer">
                <small class="text-muted">Options shown are Out of The Money (OTM). Higher percentage = further OTM = lower premium but less risk.</small>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-12">
        <div class="card shadow-sm">
            <div class="card-header">
                <h5 class="mb-0">Top Portfolio Positions</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Position</th>
                                <th>Market Price</th>
                                <th>Market Value</th>
                                <th>Unrealized P&L</th>
                            </tr>
                        </thead>
                        <tbody id="positions-table">
                            <tr>
                                <td colspan="5" class="text-center">Loading positions...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="card-footer text-end">
                <a href="/portfolio" class="btn btn-sm btn-primary">View All</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Wait for DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize data structures
        const tickersData = {};
        
        // Helper function to format currency
        function formatCurrency(value) {
            if (value === undefined || value === null || (typeof value === 'number' && isNaN(value))) return '$0.00';
            return '$' + parseFloat(value).toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&,');
        }
        
        // Helper function to format strike prices without trailing zeros
        function formatStrike(strike) {
            if (strike === undefined || strike === null || (typeof strike === 'number' && isNaN(strike))) return 'N/A';
            return parseFloat(strike) === parseInt(strike) ? parseInt(strike).toString() : parseFloat(strike).toString();
        }
        
        // Helper function to format dates
        function formatDate(date) {
            if (!date || !(date instanceof Date) || isNaN(date)) return 'Invalid Date';
            
            // Format as MM/DD/YYYY
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const year = date.getFullYear();
            
            return `${month}/${day}/${year}`;
        }
        
        // Fetch portfolio data
        function loadPortfolioData() {
            fetch('/api/portfolio')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('account-value').textContent = formatCurrency(data.account_value || 0);
                    document.getElementById('cash-balance').textContent = formatCurrency(data.cash_balance || 0);
                    document.getElementById('positions-count').textContent = data.positions_count || 0;
                    
                    // Set daily change percentage
                    const dailyChange = document.getElementById('daily-change');
                    if (data.unrealized_pnl > 0) {
                        dailyChange.textContent = `+${data.unrealized_pnl.toFixed(2)}% today`;
                        dailyChange.classList.add('text-success');
                    } else if (data.unrealized_pnl < 0) {
                        dailyChange.textContent = `${data.unrealized_pnl.toFixed(2)}% today`;
                        dailyChange.classList.add('text-danger');
                    }
                })
                .catch(error => {
                    console.error('Error fetching portfolio data:', error);
                });
        }
        
        // Fetch positions
        function loadPositionsTable() {
            fetch('/api/portfolio/positions')
                .then(response => response.json())
                .then(data => {
                    const positionsTable = document.getElementById('positions-table');
                    positionsTable.innerHTML = '';
                    
                    if (!data || data.length === 0) {
                        positionsTable.innerHTML = '<tr><td colspan="5" class="text-center">No positions found</td></tr>';
                        return;
                    }
                    
                    // Sort positions by market value (descending)
                    data.sort((a, b) => b.market_value - a.market_value);
                    
                    // Show top 5 positions
                    data.slice(0, 5).forEach(position => {
                        const row = document.createElement('tr');
                        
                        // Format unrealized P&L cell with color
                        const pnlClass = position.unrealized_pnl >= 0 ? 'text-success' : 'text-danger';
                        const pnlPrefix = position.unrealized_pnl >= 0 ? '+' : '';
                        
                        row.innerHTML = `
                            <td><strong>${position.symbol}</strong></td>
                            <td>${position.position}</td>
                            <td>${formatCurrency(position.market_price)}</td>
                            <td>${formatCurrency(position.market_value)}</td>
                            <td class="${pnlClass}">${pnlPrefix}${formatCurrency(position.unrealized_pnl)}</td>
                        `;
                        
                        positionsTable.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error fetching positions:', error);
                    const positionsTable = document.getElementById('positions-table');
                    positionsTable.innerHTML = '<tr><td colspan="5" class="text-center text-danger">Error loading positions</td></tr>';
                });
        }
        
        // Fetch options for a specific ticker
        function fetchOptionsForTicker(ticker) {
            if (!ticker) {
                console.error('No ticker provided to fetchOptionsForTicker');
                return;
            }
            
            if (!tickersData[ticker]) {
                console.error(`Ticker data not found for ${ticker}`);
                return;
            }
            
            const tickerData = tickersData[ticker];
            const otmPercentage = tickerData.otmPercentage || 10; // Default to 10% if not set
            
            console.log(`Preparing to fetch real-time options for ${ticker} with OTM ${otmPercentage}%`);
            
            // Mark as loading
            tickerData.isLoading = true;
            
            // Update UI to show loading
            const row = document.getElementById(`ticker-row-${ticker}`);
            if (!row) {
                console.error(`Row not found for ticker ${ticker}`);
                return;
            }
            
            const tdElements = row.querySelectorAll('td');
            
            // Make sure we have the correct number of cells
            if (tdElements.length < 8) {
                console.error(`Not enough TD elements for ticker ${ticker}, found ${tdElements.length}, expected at least 8`);
                // Try to fix the row structure if it's incorrect
                fixRowStructure(row, ticker);
                return;
            }
            
            // Show loading spinners
            tdElements[4].innerHTML = '<div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div>';
            tdElements[5].innerHTML = '';
            tdElements[6].innerHTML = '<div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div>';
            tdElements[7].innerHTML = '';
            
            // Build the API URL with proper encoding, adding real_time=true parameter
            // Also add a timestamp to prevent caching
            const timestamp = new Date().getTime();
            const apiUrl = `/api/options/otm?tickers=${encodeURIComponent(ticker)}&otm=${otmPercentage}&real_time=true&options_only=true&t=${timestamp}`;
            console.log(`Fetching options ONLY from API: ${apiUrl}`);
            
            // Make API call to get the options data with no-cache headers
            fetch(apiUrl, {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            })
            .then(response => {
                if (!response.ok) {
                    console.error(`HTTP error ${response.status} for ${apiUrl}`);
                    throw new Error(`HTTP error ${response.status}`);
                }
                // Get the response as text first to handle NaN values
                return response.text();
            })
            .then(text => {
                // Replace NaN with null in the response text before parsing as JSON
                // This fixes JSON parsing errors with NaN values
                const cleanedText = text.replace(/:NaN/g, ':null');
                try {
                    const data = JSON.parse(cleanedText);
                    console.log(`Received real-time data for ${ticker}:`, data);
                    
                    if (!data || !data.data || !data.data[ticker]) {
                        console.error(`Invalid data structure received for ${ticker}`, data);
                        throw new Error('Invalid data structure');
                    }
                    
                    // Store the data
                    tickerData.data = data;
                    tickerData.isLoading = false;
                    tickerData.lastUpdated = new Date();
                    
                    // Update UI with the data
                    updateTickerRow(ticker, data);
                } catch (parseError) {
                    console.error(`JSON parsing error for ${ticker}:`, parseError);
                    console.error('Original response text:', text);
                    console.error('Cleaned response text:', cleanedText);
                    throw new Error(`JSON parsing error: ${parseError.message}`);
                }
            })
            .catch(error => {
                console.error(`Error fetching real-time options for ${ticker}:`, error);
                tickerData.isLoading = false;
                
                const tdElements = row.querySelectorAll('td');
                if (tdElements && tdElements.length >= 8) {
                    // Show error in the UI
                    tdElements[4].innerHTML = 'Error';
                    tdElements[5].innerHTML = '';
                    tdElements[6].innerHTML = 'Error loading options';
                    tdElements[7].innerHTML = '';
                }
            });
        }
        
        // Function to fix row structure if it's not correct
        function fixRowStructure(row, ticker) {
            console.log(`Attempting to fix row structure for ${ticker}`);
            
            if (!row || !ticker || !tickersData[ticker]) return;
            
            const position = tickersData[ticker];
            
            // Clear and rebuild the row with correct structure
            row.innerHTML = `
                <td><strong>${ticker}</strong></td>
                <td>${formatCurrency(position.price)}</td>
                <td>${position.position}</td>
                <td>
                    <div class="input-group input-group-sm" style="width: 120px;">
                        <input type="range" class="form-range otm-slider" id="otm-${ticker}" 
                               min="5" max="30" step="5" value="${position.otmPercentage || 10}" 
                               data-ticker="${ticker}">
                        <span class="input-group-text" id="otm-value-${ticker}">${position.otmPercentage || 10}%</span>
                    </div>
                </td>
                <td>Loading...</td>
                <td></td>
                <td>Loading...</td>
                <td></td>
                <td>
                    <!-- Removed the redundant refresh button here -->
                </td>
            `;
            
            // Re-attach event listeners for this row
            const slider = row.querySelector('.otm-slider');
            if (slider) {
                slider.addEventListener('input', function() {
                    const value = this.value;
                    const valueElement = document.getElementById(`otm-value-${ticker}`);
                    if (valueElement) {
                        valueElement.textContent = `${value}%`;
                    }
                    tickersData[ticker].otmPercentage = parseInt(value);
                    console.log(`Updated OTM for ${ticker} to ${value}%`);
                });
            }
            
            // We no longer need this refresh button since we have the Refresh Data button
            
            // Add a new fetch button since we removed the original one
            const fetchBtn = document.createElement('button');
            fetchBtn.className = 'btn btn-sm btn-primary fetch-btn';
            fetchBtn.setAttribute('data-ticker', ticker);
            fetchBtn.textContent = 'Fetch Options';
            fetchBtn.addEventListener('click', function() {
                console.log(`Fetch button clicked for ${ticker}`);
                fetchOptionsForTicker(ticker);
            });
            
            // Add the fetch button to cell 5 (index 4)
            const tdElements = row.querySelectorAll('td');
            if (tdElements.length >= 5) {
                tdElements[4].innerHTML = '';
                tdElements[4].appendChild(fetchBtn);
            }
            
            console.log(`Row structure fixed for ${ticker}, attempting to fetch options again`);
            setTimeout(() => fetchOptionsForTicker(ticker), 500);
        }
        
        // Update a ticker row with options data
        function updateTickerRow(ticker, data) {
            if (!ticker || !data || !data.data || !data.data[ticker]) {
                console.error('Invalid data structure for ticker', ticker, data);
                return;
            }
            
            const option = data.data[ticker];
            const row = document.getElementById(`ticker-row-${ticker}`);
            if (!row) return;
            
            const tdElements = row.querySelectorAll('td');
            if (!tdElements || tdElements.length < 8) return;
            
            // Log the full option data to debug premium issues
            console.log(`Real-time option data for ${ticker}:`, option);
            
            // Calculate call and put earnings display
            let callContent = 'N/A';
            let callPremium = 'N/A';
            let putContent = 'N/A';
            let putPremium = 'N/A';
            
            // Handle the new data structure with 'calls' and 'puts' arrays
            let callOption = null;
            let putOption = null;
            
            // Extract the first call option from the calls array if it exists
            if (option.calls && option.calls.length > 0) {
                callOption = option.calls[0];
            } 
            // Fallback to the 'call' property if it exists (for backwards compatibility)
            else if (option.call) {
                callOption = option.call;
            }
            
            // Extract the first put option from the puts array if it exists
            if (option.puts && option.puts.length > 0) {
                putOption = option.puts[0];
            } 
            // Fallback to the 'put' property if it exists (for backwards compatibility)
            else if (option.put) {
                putOption = option.put;
            }
            
            // Process call option if available
            if (callOption) {
                // Show the raw bid/ask values with more decimal places to see if they're very small but non-zero
                const callBid = callOption.bid !== undefined ? callOption.bid : 'undefined';
                const callAsk = callOption.ask !== undefined ? callOption.ask : 'undefined';
                
                // Handle NaN values safely
                const safeCallBid = typeof callBid === 'number' && !isNaN(callBid) ? callBid : 0;
                const safeCallAsk = typeof callAsk === 'number' && !isNaN(callAsk) ? callAsk : 0;
                
                // Check for very small values that might be treated as zero
                const hasSmallBidAsk = (safeCallBid > 0 && safeCallBid < 0.01) || (safeCallAsk > 0 && safeCallAsk < 0.01);
                
                console.log(`Call raw values for ${ticker}: bid=${safeCallBid.toFixed(6)}, ask=${safeCallAsk.toFixed(6)}, hasSmallValues=${hasSmallBidAsk}`);
                
                const safeStrike = callOption.strike !== undefined && !isNaN(callOption.strike) ? callOption.strike : 0;
                const safeDelta = callOption.delta !== undefined && !isNaN(callOption.delta) ? callOption.delta : null;
                
                callContent = formatStrike(safeStrike) + (safeDelta ? ` (δ=${safeDelta.toFixed(2)})` : '');
                
                // Log call earnings data
                console.log(`Call earnings for ${ticker}:`, callOption.earnings);
                
                if (callOption.earnings) {
                    const e = callOption.earnings;
                    
                    // Safely extract values, handling NaN
                    const premiumPerContract = e.premium_per_contract !== undefined && !isNaN(e.premium_per_contract) ? e.premium_per_contract : 0;
                    const totalPremium = e.total_premium !== undefined && !isNaN(e.total_premium) ? e.total_premium : 0;
                    const returnOnCapital = e.return_on_capital !== undefined && !isNaN(e.return_on_capital) ? e.return_on_capital : 0;
                    const maxContracts = e.max_contracts !== undefined && !isNaN(e.max_contracts) ? e.max_contracts : 0;
                    
                    // Show raw premium value with more decimal places
                    console.log(`Call premium raw value for ${ticker}: ${premiumPerContract.toFixed(6)}`);
                    
                    // Check if we actually have valid premium values
                    if (premiumPerContract > 0 && totalPremium > 0) {
                        callPremium = `${maxContracts} × ${formatCurrency(premiumPerContract)} = ${formatCurrency(totalPremium)} (${returnOnCapital.toFixed(2)}%)`;
                    } else {
                        // Show exact bid/ask values with more decimal places
                        callPremium = `<span class="text-muted">No premium available</span><br>
                            <small class="text-muted">Bid: ${safeCallBid.toFixed(6)}, Ask: ${safeCallAsk.toFixed(6)}</small>
                            ${hasSmallBidAsk ? '<br><small class="text-warning">⚠️ Very small values detected</small>' : ''}`;
                    }
                } else {
                    callPremium = `<span class="text-muted">No earnings data available</span><br>
                        <small class="text-muted">Bid: ${safeCallBid.toFixed(6)}, Ask: ${safeCallAsk.toFixed(6)}</small>
                        ${hasSmallBidAsk ? '<br><small class="text-warning">⚠️ Very small values detected</small>' : ''}`;
                }
            }
            
            // Process put option if available
            if (putOption) {
                // Show the raw bid/ask values with more decimal places to see if they're very small but non-zero
                const putBid = putOption.bid !== undefined ? putOption.bid : 'undefined';
                const putAsk = putOption.ask !== undefined ? putOption.ask : 'undefined';
                
                // Handle NaN values safely
                const safePutBid = typeof putBid === 'number' && !isNaN(putBid) ? putBid : 0;
                const safePutAsk = typeof putAsk === 'number' && !isNaN(putAsk) ? putAsk : 0;
                
                // Check for very small values that might be treated as zero
                const hasSmallBidAsk = (safePutBid > 0 && safePutBid < 0.01) || (safePutAsk > 0 && safePutAsk < 0.01);
                
                console.log(`Put raw values for ${ticker}: bid=${safePutBid.toFixed(6)}, ask=${safePutAsk.toFixed(6)}, hasSmallValues=${hasSmallBidAsk}`);
                
                const safeStrike = putOption.strike !== undefined && !isNaN(putOption.strike) ? putOption.strike : 0;
                const safeDelta = putOption.delta !== undefined && !isNaN(putOption.delta) ? putOption.delta : null;
                
                putContent = formatStrike(safeStrike) + (safeDelta ? ` (δ=${safeDelta.toFixed(2)})` : '');
                
                // Log put earnings data
                console.log(`Put earnings for ${ticker}:`, putOption.earnings);
                
                if (putOption.earnings) {
                    const e = putOption.earnings;
                    
                    // Safely extract values, handling NaN
                    const premiumPerContract = e.premium_per_contract !== undefined && !isNaN(e.premium_per_contract) ? e.premium_per_contract : 0;
                    const totalPremium = e.total_premium !== undefined && !isNaN(e.total_premium) ? e.total_premium : 0;
                    const returnOnCash = e.return_on_cash !== undefined && !isNaN(e.return_on_cash) ? e.return_on_cash : 0;
                    const maxContracts = e.max_contracts !== undefined && !isNaN(e.max_contracts) ? e.max_contracts : 0;
                    
                    // Show raw premium value with more decimal places
                    console.log(`Put premium raw value for ${ticker}: ${premiumPerContract.toFixed(6)}`);
                    
                    // Check if we actually have valid premium values
                    if (premiumPerContract > 0 && totalPremium > 0) {
                        putPremium = `${maxContracts} × ${formatCurrency(premiumPerContract)} = ${formatCurrency(totalPremium)} (${returnOnCash.toFixed(2)}%)`;
                    } else {
                        // Show exact bid/ask values with more decimal places
                        putPremium = `<span class="text-muted">No premium available</span><br>
                            <small class="text-muted">Bid: ${safePutBid.toFixed(6)}, Ask: ${safePutAsk.toFixed(6)}</small>
                            ${hasSmallBidAsk ? '<br><small class="text-warning">⚠️ Very small values detected</small>' : ''}`;
                    }
                } else {
                    putPremium = `<span class="text-muted">No earnings data available</span><br>
                        <small class="text-muted">Bid: ${safePutBid.toFixed(6)}, Ask: ${safePutAsk.toFixed(6)}</small>
                        ${hasSmallBidAsk ? '<br><small class="text-warning">⚠️ Very small values detected</small>' : ''}`;
                }
            }
            
            // Show expiration date from the data
            let expirationDate = null;
            
            // Try to get expiration date from various sources
            if (option.expiration) {
                // Direct expiration property
                expirationDate = new Date(option.expiration);
            } else if (callOption && callOption.expiration) {
                // From call option
                const expStr = callOption.expiration;
                expirationDate = new Date(
                    expStr.substring(0, 4) + '-' + 
                    expStr.substring(4, 6) + '-' + 
                    expStr.substring(6, 8)
                );
            } else if (putOption && putOption.expiration) {
                // From put option
                const expStr = putOption.expiration;
                expirationDate = new Date(
                    expStr.substring(0, 4) + '-' + 
                    expStr.substring(4, 6) + '-' + 
                    expStr.substring(6, 8)
                );
            }
            
            const expirationText = expirationDate ? 
                `<small class="text-muted">Exp: ${formatDate(expirationDate)}</small>` : 
                '';
            
            // Format the last updated time
            const now = new Date();
            const lastUpdated = tickersData[ticker].lastUpdated || now;
            const timeDiff = Math.round((now - lastUpdated) / 1000);
            const lastUpdatedText = `<small class="text-success">Real-time data as of ${lastUpdated.toLocaleTimeString()}</small>`;
            
            // Update the cells with extra information
            tdElements[4].innerHTML = `${callContent}<br>${expirationText}<br>${lastUpdatedText}`;
            tdElements[5].innerHTML = callPremium;
            tdElements[6].innerHTML = `${putContent}<br>${expirationText}`;
            tdElements[7].innerHTML = putPremium;
            
            // Add OTM information
            const otmInfo = document.createElement('div');
            otmInfo.className = 'mt-2';
            otmInfo.innerHTML = `<small class="text-muted">Using OTM: ${option.otm_percentage || tickersData[ticker].otmPercentage}%</small>`;
            
            // Add a data refresh button after options are loaded
            const refreshBtn = document.createElement('button');
            refreshBtn.className = 'btn btn-sm btn-outline-primary fetch-btn mt-2';
            refreshBtn.setAttribute('data-ticker', ticker);
            refreshBtn.innerHTML = `<i class="bi bi-arrow-repeat"></i> Refresh Data`;
            refreshBtn.addEventListener('click', function() {
                fetchOptionsForTicker(ticker);
            });
            
            // Add the OTM info to the Sell Call cell and the refresh button to the Actions cell (last column)
            const fetchBtnContainer = document.createElement('div');
            fetchBtnContainer.className = 'mt-2';
            fetchBtnContainer.appendChild(refreshBtn);
            
            // Add OTM info to the Sell Call cell if not already present
            if (tdElements[4].querySelector('.text-muted') === null) {
                tdElements[4].appendChild(otmInfo);
            }
            
            // Add refresh button to the Actions column (last column - index 8)
            if (tdElements[8] && tdElements[8].querySelector('.fetch-btn') === null) {
                tdElements[8].appendChild(fetchBtnContainer);
            }
        }
        
        // Refresh all tickers
        function refreshAllOptions() {
            const tickers = Object.keys(tickersData);
            if (tickers.length === 0) return;
            
            // Process each ticker with a small delay
            tickers.forEach((ticker, index) => {
                setTimeout(() => {
                    fetchOptionsForTicker(ticker);
                }, index * 1000); // 1 second delay between each
            });
        }
        
        // Add event listeners after tickers are loaded
        function setupEventListeners() {
            try {
                // Add event listeners to all OTM sliders
                document.querySelectorAll('.otm-slider').forEach(slider => {
                    slider.addEventListener('input', function() {
                        const ticker = this.getAttribute('data-ticker');
                        const value = this.value;
                        
                        if (ticker && tickersData[ticker]) {
                            // Update display and store state
                            const valueElement = document.getElementById(`otm-value-${ticker}`);
                            if (valueElement) {
                                valueElement.textContent = `${value}%`;
                            }
                            tickersData[ticker].otmPercentage = parseInt(value);
                            console.log(`Updated OTM for ${ticker} to ${value}%`);
                        }
                    });
                });
                
                // Add event listeners to all fetch buttons
                document.querySelectorAll('.fetch-btn').forEach(button => {
                    button.addEventListener('click', function() {
                        const ticker = this.getAttribute('data-ticker');
                        if (ticker) {
                            console.log(`Fetch button clicked for ${ticker}`);
                            fetchOptionsForTicker(ticker);
                        } else {
                            console.error('Fetch button clicked but no ticker attribute found');
                        }
                    });
                });
                
                // Add refresh all button handler
                const refreshAllBtn = document.getElementById('refresh-all-options');
                if (refreshAllBtn) {
                    refreshAllBtn.addEventListener('click', function() {
                        console.log('Refresh all button clicked');
                        refreshAllOptions();
                    });
                }
                
                console.log('All event listeners set up successfully');
            } catch (error) {
                console.error('Error setting up event listeners:', error);
            }
        }
        
        // Fetch tickers and initialize the options table
        function fetchTickers() {
            const optionsTable = document.getElementById('options-table');
            if (!optionsTable) {
                console.error('Options table not found');
                return;
            }
            
            optionsTable.innerHTML = '<tr><td colspan="9" class="text-center">Loading tickers...</td></tr>';
            
            fetch('/api/portfolio/positions')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    optionsTable.innerHTML = '';
                    
                    if (!data || data.length === 0) {
                        optionsTable.innerHTML = '<tr><td colspan="9" class="text-center">No tickers found</td></tr>';
                        return;
                    }
                    
                    console.log('Loaded tickers data:', data);
                    
                    // Sort positions by market value (descending)
                    data.sort((a, b) => b.market_value - a.market_value);
                    
                    // Create a row for each ticker with OTM slider
                    data.forEach(position => {
                        const ticker = position.symbol;
                        
                        // Store ticker info in our state object with default OTM of 10%
                        tickersData[ticker] = {
                            otmPercentage: 10,
                            price: position.market_price,
                            position: position.position,
                            data: null,
                            isLoading: false
                        };
                        
                        const row = document.createElement('tr');
                        row.id = `ticker-row-${ticker}`;
                        
                        // Ensure we're adding 9 cells to each row (9 columns in the table)
                        row.innerHTML = `
                            <td><strong>${ticker}</strong></td>
                            <td>${formatCurrency(position.market_price)}</td>
                            <td>${position.position}</td>
                            <td>
                                <div class="input-group input-group-sm" style="width: 120px;">
                                    <input type="range" class="form-range otm-slider" id="otm-${ticker}" 
                                           min="5" max="30" step="5" value="10" 
                                           data-ticker="${ticker}">
                                    <span class="input-group-text" id="otm-value-${ticker}">10%</span>
                                </div>
                            </td>
                            <td><!-- Sell Call --></td>
                            <td><!-- Call Premium --></td>
                            <td><!-- Sell Put --></td>
                            <td><!-- Put Premium --></td>
                            <td><!-- Actions - will be filled with Refresh Data button later --></td>
                        `;
                        
                        // Add row to the table
                        optionsTable.appendChild(row);
                        
                        // Now place the fetch button in the Sell Call column (5th column, index 4)
                        const tdElements = row.querySelectorAll('td');
                        if (tdElements.length >= 5) {
                            const fetchBtn = document.createElement('button');
                            fetchBtn.className = 'btn btn-sm btn-primary fetch-btn';
                            fetchBtn.setAttribute('data-ticker', ticker);
                            fetchBtn.textContent = 'Fetch Options';
                            tdElements[4].innerHTML = '';
                            tdElements[4].appendChild(fetchBtn);
                        }
                    });
                    
                    console.log('Ticker rows created, setting up event listeners');
                    // Set up event listeners
                    setupEventListeners();
                    
                    // Verify table structure
                    document.querySelectorAll('#options-table tr').forEach(row => {
                        const cells = row.querySelectorAll('td');
                        console.log(`Row ${row.id} has ${cells.length} cells`);
                    });
                    
                    // Load first ticker automatically
                    if (Object.keys(tickersData).length > 0) {
                        console.log('Auto-loading first ticker');
                        const firstTicker = Object.keys(tickersData)[0];
                        setTimeout(() => {
                            fetchOptionsForTicker(firstTicker);
                        }, 500);
                    }
                })
                .catch(error => {
                    console.error('Error fetching tickers:', error);
                    optionsTable.innerHTML = '<tr><td colspan="9" class="text-center text-danger">Error loading tickers</td></tr>';
                });
        }
        
        // Test API connection with real-time data
        function testApiEndpoint() {
            console.log('Testing real-time API endpoint...');
            const timestamp = new Date().getTime();
            fetch(`/api/options/otm?tickers=AAPL&otm=10&real_time=true&options_only=true&t=${timestamp}`, {
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            })
            .then(response => {
                console.log('Real-time API test response status:', response.status);
                if (!response.ok) {
                    console.error('Real-time API test failed with status:', response.status);
                    return;
                }
                console.log('Real-time API test successful!');
                // Get the response as text first to handle NaN values
                return response.text();
            })
            .then(text => {
                if (!text) return;
                
                // Replace NaN with null in the response text before parsing as JSON
                const cleanedText = text.replace(/:NaN/g, ':null');
                try {
                    const data = JSON.parse(cleanedText);
                    console.log('Sample real-time data received:', data);
                    
                    // Check for the presence of bid/ask values
                    if (data.data && data.data.AAPL) {
                        const appleData = data.data.AAPL;
                        
                        // Try to extract call data from either 'call' property or first item in 'calls' array
                        let callOption = null;
                        if (appleData.calls && appleData.calls.length > 0) {
                            callOption = appleData.calls[0];
                            console.log('AAPL call found in calls array:', callOption);
                        } else if (appleData.call) {
                            callOption = appleData.call;
                            console.log('AAPL call found in call property:', callOption);
                        }
                        
                        if (callOption) {
                            console.log('AAPL call bid/ask:', callOption.bid, callOption.ask);
                        } else {
                            console.log('No call option data found for AAPL');
                        }
                    }
                } catch (parseError) {
                    console.error('JSON parsing error in test endpoint:', parseError);
                    console.error('Original response text:', text);
                    console.error('Cleaned response text:', cleanedText);
                }
            })
            .catch(error => {
                console.error('Real-time API test error:', error);
            });
        }
        
        // Initialize all dashboard components
        try {
            console.log('Initializing dashboard...');
            loadPortfolioData();
            loadPositionsTable();
            fetchTickers();
            
            // Test API endpoints
            setTimeout(testApiEndpoint, 1000);
        } catch (error) {
            console.error('Error initializing dashboard:', error);
        }
    });
</script>
{% endblock %} 