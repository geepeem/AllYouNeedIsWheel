{% extends "base.html" %}

{% block title %}Dashboard - Auto-Trader{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-md-12">
        <h1>Dashboard</h1>
        <p class="lead">Overview of your portfolio and trading activity</p>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-4">
        <div class="card shadow-sm h-100">
            <div class="card-body">
                <h5 class="card-title">Portfolio Value</h5>
                <h2 class="display-4 mb-0" id="account-value">$0.00</h2>
                <p class="text-muted" id="daily-change">0.00% today</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card shadow-sm h-100">
            <div class="card-body">
                <h5 class="card-title">Cash Balance</h5>
                <h2 class="display-4 mb-0" id="cash-balance">$0.00</h2>
                <p class="text-muted">Available for trading</p>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card shadow-sm h-100">
            <div class="card-body">
                <h5 class="card-title">Positions</h5>
                <h2 class="display-4 mb-0" id="positions-count">0</h2>
                <p class="text-muted">Active positions</p>
            </div>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-12">
        <div class="card shadow-sm">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Option Opportunities</h5>
                <div class="d-flex align-items-center">
                    <button class="btn btn-sm btn-outline-primary me-2" id="refresh-all-options">
                        <i class="bi bi-arrow-repeat"></i> Refresh All
                    </button>
                    <button class="btn btn-sm btn-outline-success me-2" id="order-all-options">
                        <i class="bi bi-plus-circle"></i> Order All
                    </button>
                    <button class="btn btn-sm btn-outline-success" id="order-selected-option" disabled>
                        <i class="bi bi-plus-circle"></i> Order
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Price</th>
                                <th>Position</th>
                                <th>OTM %</th>
                                <th>Sell Call</th>
                                <th>Call Premium</th>
                                <th>Sell Put</th>
                                <th>Put Premium</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="options-table">
                            <tr>
                                <td colspan="9" class="text-center">Loading options data...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="card-footer">
                <small class="text-muted">Options shown are Out of The Money (OTM). Higher percentage = further OTM = lower premium but less risk.</small>
            </div>
        </div>
    </div>
</div>

<!-- Pending Orders Section -->
<div class="row mb-4">
    <div class="col-md-12">
        <div class="card shadow-sm">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Pending Option Orders</h5>
                <div class="d-flex align-items-center">
                    <button class="btn btn-sm btn-outline-primary" id="refresh-pending-orders">
                        <i class="bi bi-arrow-repeat"></i> Refresh
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Symbol</th>
                                <th>Type</th>
                                <th>Strike</th>
                                <th>Expiration</th>
                                <th>Premium</th>
                                <th>Quantity</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="pending-orders-table">
                            <tr>
                                <td colspan="9" class="text-center">Loading pending orders...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="card-footer">
                <small class="text-muted">Pending orders will be executed when market conditions are favorable. Check the status for updates.</small>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-12">
        <div class="card shadow-sm">
            <div class="card-header">
                <h5 class="mb-0">Top Portfolio Positions</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Position</th>
                                <th>Market Price</th>
                                <th>Market Value</th>
                                <th>Unrealized P&L</th>
                            </tr>
                        </thead>
                        <tbody id="positions-table">
                            <tr>
                                <td colspan="5" class="text-center">Loading positions...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="card-footer text-end">
                <a href="/portfolio" class="btn btn-sm btn-primary">View All</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Wait for DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize data structures
        const tickersData = {};
        let selectedOption = null; // Track the currently selected option for ordering
        
        // Utility functions
        function formatCurrency(value) {
            if (value === undefined || value === null) return '$0.00';
            return '$' + parseFloat(value).toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&,');
        }
        
        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            
            // Handle YYYYMMDD format (common for options expiration)
            if (dateString.length === 8 && !isNaN(dateString)) {
                const year = dateString.substring(0, 4);
                const month = dateString.substring(4, 6);
                const day = dateString.substring(6, 8);
                return new Date(year, month - 1, day).toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
            }
            
            // Try standard date parsing
            const date = new Date(dateString);
            if (isNaN(date.getTime())) {
                return 'Invalid Date';
            }
            
            return date.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }
        
        function formatStrike(strike) {
            if (!strike || strike === 0) return 'N/A';
            return formatCurrency(strike);
        }
        
        // Load pending orders table
        function loadPendingOrders() {
            const pendingOrdersTable = document.getElementById('pending-orders-table');
            
            if (!pendingOrdersTable) return;
            
            // Show loading message - update to use pendingOrdersTable directly
            pendingOrdersTable.innerHTML = '<tr><td colspan="9" class="text-center">Loading orders...</td></tr>';
            
            fetch('/api/options/pending-orders')
                .then(response => response.json())
                .then(data => {
                    if (!data || !data.orders || data.orders.length === 0) {
                        pendingOrdersTable.innerHTML = '<tr><td colspan="9" class="text-center">No pending orders found</td></tr>';
                        return;
                    }
                    
                    // Clear the table
                    pendingOrdersTable.innerHTML = '';
                    
                    // Add rows for each order
                    data.orders.forEach(order => {
                        const orderDate = new Date(order.timestamp * 1000);
                        const formattedDate = orderDate.toLocaleString();
                        
                        // Parse details if it's a string
                        let details = order.details;
                        if (typeof details === 'string') {
                            try {
                                details = JSON.parse(details);
                            } catch (e) {
                                details = {};
                            }
                        }
                        
                        // Try to get expiration from details if available, otherwise use order.expiration
                        const expiration = details.expiry || details.expiration || order.expiration;
                        
                        // Debug logging for expiration date
                        console.log(`Order ${order.id} expiration data:`, {
                            orderExpiration: order.expiration,
                            detailsExpiry: details.expiry,
                            detailsExpiration: details.expiration,
                            finalExpiration: expiration,
                            formattedDate: formatDate(expiration)
                        });
                        
                        // Create row
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${formattedDate}</td>
                            <td>${order.ticker}</td>
                            <td>${order.option_type || 'N/A'}</td>
                            <td>${formatStrike(order.strike)}</td>
                            <td>${formatDate(expiration)}</td>
                            <td>${formatCurrency(order.premium) || '$0.00'}</td>
                            <td>${order.quantity || 1}</td>
                            <td><span class="badge bg-${getBadgeColor(order.status)}">${order.status}</span></td>
                            <td>
                                <button class="btn btn-sm btn-success execute-btn" data-order-id="${order.id}">Execute</button>
                                <button class="btn btn-sm btn-danger cancel-btn" data-order-id="${order.id}">Cancel</button>
                            </td>
                        `;
                        pendingOrdersTable.appendChild(row);
                    });
                    
                    // Add event listeners to cancel buttons
                    const cancelButtons = pendingOrdersTable.querySelectorAll('.cancel-btn');
                    cancelButtons.forEach(button => {
                        button.addEventListener('click', () => {
                            const orderId = button.getAttribute('data-order-id');
                            cancelOrder(orderId);
                        });
                    });
                    
                    // Add event listeners to execute buttons
                    const executeButtons = pendingOrdersTable.querySelectorAll('.execute-btn');
                    executeButtons.forEach(button => {
                        button.addEventListener('click', () => {
                            const orderId = button.getAttribute('data-order-id');
                            executeOrder(orderId);
                        });
                    });
                })
                .catch(error => {
                    console.error('Error loading pending orders:', error);
                    pendingOrdersTable.innerHTML = `<tr><td colspan="9" class="text-center text-danger">Error loading orders: ${error.message}</td></tr>`;
                });
        }
        
        // Cancel an order
        function cancelOrder(orderId) {
            fetch(`/api/options/order/${orderId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || 'Failed to cancel order');
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('Order cancelled:', data);
                // Refresh the pending orders list
                loadPendingOrders();
                // Show success message
                showAlert('Order cancelled successfully', 'success');
            })
            .catch(error => {
                console.error('Error cancelling order:', error);
                showAlert(`Error cancelling order: ${error.message}`, 'danger');
            });
        }
        
        // Execute an order through TWS
        function executeOrder(orderId) {
            fetch(`/api/options/execute/${orderId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || 'Failed to execute order');
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('Order executed:', data);
                // Refresh the pending orders list
                loadPendingOrders();
                // Show success message
                showAlert(`Order sent to TWS for execution (IB Order ID: ${data.ib_order_id})`, 'success');
            })
            .catch(error => {
                console.error('Error executing order:', error);
                showAlert(`Error executing order: ${error.message}`, 'danger');
            });
        }
        
        // Function to show alerts (add after executeOrder if it doesn't exist)
        function showAlert(message, type = 'info') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
            alertDiv.role = 'alert';
            alertDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            
            // Add the alert at the top of the content container
            const contentContainer = document.querySelector('.content-container');
            if (contentContainer) {
                contentContainer.prepend(alertDiv);
                
                // Auto-dismiss after 5 seconds
                setTimeout(() => {
                    alertDiv.classList.remove('show');
                    setTimeout(() => alertDiv.remove(), 150);
                }, 5000);
            }
        }
        
        // Helper function to get badge color based on order status
        function getBadgeColor(status) {
            switch(status) {
                case 'pending':
                    return 'warning';
                case 'completed':
                    return 'success';
                case 'cancelled':
                    return 'danger';
                case 'processing':
                    return 'info';
                default:
                    return 'secondary';
            }
        }
        
        // Place an order for the selected option
        function placeOrder() {
            if (!selectedOption) {
                alert('Please select an option to order first');
                return;
            }
            
            console.log('Placing order for:', selectedOption);
            
            fetch('/api/options/order', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(selectedOption)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Order placed successfully:', data);
                alert('Order placed successfully!');
                
                // Reset selected option
                selectedOption = null;
                document.getElementById('order-selected-option').disabled = true;
                
                // Remove selected class from all options
                document.querySelectorAll('.option-row.selected').forEach(row => {
                    row.classList.remove('selected');
                });
                
                // Reload pending orders table
                loadPendingOrders();
            })
            .catch(error => {
                console.error('Error placing order:', error);
                alert('Error placing order: ' + error.message);
            });
        }
        
        // Fetch portfolio data
        function loadPortfolioData() {
            fetch('/api/portfolio')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('account-value').textContent = formatCurrency(data.account_value || 0);
                    document.getElementById('cash-balance').textContent = formatCurrency(data.cash_balance || 0);
                    document.getElementById('positions-count').textContent = data.positions_count || 0;
                    
                    // Set daily change percentage
                    const dailyChange = document.getElementById('daily-change');
                    if (data.unrealized_pnl > 0) {
                        dailyChange.textContent = `+${data.unrealized_pnl.toFixed(2)}% today`;
                        dailyChange.classList.add('text-success');
                    } else if (data.unrealized_pnl < 0) {
                        dailyChange.textContent = `${data.unrealized_pnl.toFixed(2)}% today`;
                        dailyChange.classList.add('text-danger');
                    }
                })
                .catch(error => {
                    console.error('Error fetching portfolio data:', error);
                });
        }
        
        // Fetch positions
        function loadPositionsTable() {
            fetch('/api/portfolio/positions')
                .then(response => response.json())
                .then(data => {
                    const positionsTable = document.getElementById('positions-table');
                    positionsTable.innerHTML = '';
                    
                    if (!data || data.length === 0) {
                        positionsTable.innerHTML = '<tr><td colspan="5" class="text-center">No positions found</td></tr>';
                        return;
                    }
                    
                    // Sort positions by market value (descending)
                    data.sort((a, b) => b.market_value - a.market_value);
                    
                    // Show top 5 positions
                    data.slice(0, 5).forEach(position => {
                        const row = document.createElement('tr');
                        
                        // Format unrealized P&L cell with color
                        const pnlClass = position.unrealized_pnl >= 0 ? 'text-success' : 'text-danger';
                        const pnlPrefix = position.unrealized_pnl >= 0 ? '+' : '';
                        
                        row.innerHTML = `
                            <td><strong>${position.symbol}</strong></td>
                            <td>${position.position}</td>
                            <td>${formatCurrency(position.market_price)}</td>
                            <td>${formatCurrency(position.market_value)}</td>
                            <td class="${pnlClass}">${pnlPrefix}${formatCurrency(position.unrealized_pnl)}</td>
                        `;
                        
                        positionsTable.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error fetching positions:', error);
                    const positionsTable = document.getElementById('positions-table');
                    positionsTable.innerHTML = '<tr><td colspan="5" class="text-center text-danger">Error loading positions</td></tr>';
                });
        }
        
        // Fetch options for a specific ticker
        function fetchOptionsForTicker(ticker) {
            if (!ticker) {
                console.error('No ticker provided to fetchOptionsForTicker');
                return;
            }
            
            if (!tickersData[ticker]) {
                console.error(`Ticker data not found for ${ticker}`);
                return;
            }
            
            const tickerData = tickersData[ticker];
            const otmPercentage = tickerData.otmPercentage || 10; // Default to 10% if not set
            
            console.log(`Preparing to fetch real-time options for ${ticker} with OTM ${otmPercentage}%`);
            
            // Mark as loading
            tickerData.isLoading = true;
            
            // Update UI to show loading
            const row = document.getElementById(`ticker-row-${ticker}`);
            if (!row) {
                console.error(`Row not found for ticker ${ticker}`);
                return;
            }
            
            const tdElements = row.querySelectorAll('td');
            
            // Make sure we have the correct number of cells
            if (tdElements.length < 8) {
                console.error(`Not enough TD elements for ticker ${ticker}, found ${tdElements.length}, expected at least 8`);
                // Try to fix the row structure if it's incorrect
                fixRowStructure(row, ticker);
                return;
            }
            
            // Show loading spinners
            tdElements[4].innerHTML = '<div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div>';
            tdElements[5].innerHTML = '';
            tdElements[6].innerHTML = '<div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div>';
            tdElements[7].innerHTML = '';
            
            // Build the API URL with proper encoding, adding real_time=true parameter
            // Also add a timestamp to prevent caching
            const timestamp = new Date().getTime();
            const apiUrl = `/api/options/otm?tickers=${encodeURIComponent(ticker)}&otm=${otmPercentage}&real_time=true&options_only=true&t=${timestamp}`;
            console.log(`Fetching options ONLY from API: ${apiUrl}`);
            
            // Make API call to get the options data with no-cache headers
            fetch(apiUrl, {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            })
            .then(response => {
                if (!response.ok) {
                    console.error(`HTTP error ${response.status} for ${apiUrl}`);
                    throw new Error(`HTTP error ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log(`Received real-time data for ${ticker}:`, data);
                
                if (!data || !data.data || !data.data[ticker]) {
                    console.error(`Invalid data structure received for ${ticker}`, data);
                    throw new Error('Invalid data structure');
                }
                
                // Store the data
                tickerData.data = data;
                tickerData.isLoading = false;
                tickerData.lastUpdated = new Date();
                
                // Update UI with the data
                updateTickerRow(ticker, data);
            })
            .catch(error => {
                console.error(`Error fetching real-time options for ${ticker}:`, error);
                tickerData.isLoading = false;
                
                const tdElements = row.querySelectorAll('td');
                if (tdElements && tdElements.length >= 8) {
                    // Show error in the UI
                    tdElements[4].innerHTML = 'Error';
                    tdElements[5].innerHTML = '';
                    tdElements[6].innerHTML = 'Error loading options';
                    tdElements[7].innerHTML = '';
                }
            });
        }
        
        // Function to fix row structure if it's not correct
        function fixRowStructure(row, ticker) {
            console.log(`Attempting to fix row structure for ${ticker}`);
            
            if (!row || !ticker || !tickersData[ticker]) return;
            
            const position = tickersData[ticker];
            
            // Clear and rebuild the row with correct structure
            row.innerHTML = `
                <td><strong>${ticker}</strong></td>
                <td>${formatCurrency(position.price)}</td>
                <td>${position.position}</td>
                <td>
                    <div class="input-group input-group-sm" style="width: 120px;">
                        <input type="range" class="form-range otm-slider" id="otm-${ticker}" 
                               min="5" max="30" step="5" value="${position.otmPercentage || 10}" 
                               data-ticker="${ticker}">
                        <span class="input-group-text" id="otm-value-${ticker}">${position.otmPercentage || 10}%</span>
                    </div>
                </td>
                <td>Loading...</td>
                <td></td>
                <td>Loading...</td>
                <td></td>
                <td>
                    <!-- Removed the redundant refresh button here -->
                </td>
            `;
            
            // Re-attach event listeners for this row
            const slider = row.querySelector('.otm-slider');
            if (slider) {
                slider.addEventListener('input', function() {
                    const value = this.value;
                    const valueElement = document.getElementById(`otm-value-${ticker}`);
                    if (valueElement) {
                        valueElement.textContent = `${value}%`;
                    }
                    tickersData[ticker].otmPercentage = parseInt(value);
                    console.log(`Updated OTM for ${ticker} to ${value}%`);
                });
            }
            
            // We no longer need this refresh button since we have the Refresh Data button
            
            // Add a new fetch button since we removed the original one
            const fetchBtn = document.createElement('button');
            fetchBtn.className = 'btn btn-sm btn-primary fetch-btn';
            fetchBtn.setAttribute('data-ticker', ticker);
            fetchBtn.textContent = 'Fetch Options';
            fetchBtn.addEventListener('click', function() {
                console.log(`Fetch button clicked for ${ticker}`);
                fetchOptionsForTicker(ticker);
            });
            
            // Add the fetch button to cell 5 (index 4)
            const tdElements = row.querySelectorAll('td');
            if (tdElements.length >= 5) {
                tdElements[4].innerHTML = '';
                tdElements[4].appendChild(fetchBtn);
            }
            
            console.log(`Row structure fixed for ${ticker}, attempting to fetch options again`);
            setTimeout(() => fetchOptionsForTicker(ticker), 500);
        }
        
        // Update a ticker row with options data
        function updateTickerRow(ticker, data) {
            if (!ticker || !data || !data.data || !data.data[ticker]) {
                console.error('Invalid data structure for ticker', ticker, data);
                return;
            }
            
            const option = data.data[ticker];
            const row = document.getElementById(`ticker-row-${ticker}`);
            if (!row) return;
            
            const tdElements = row.querySelectorAll('td');
            if (!tdElements || tdElements.length < 8) return;
            
            // Log the full option data to debug premium issues
            console.log(`Real-time option data for ${ticker}:`, option);
            
            // Calculate call and put earnings display
            let callContent = 'N/A';
            let callPremium = 'N/A';
            let putContent = 'N/A';
            let putPremium = 'N/A';
            
            // Handle the new data structure with 'calls' and 'puts' arrays
            let callOption = null;
            let putOption = null;
            
            // Extract the first call option from the calls array if it exists
            if (option.calls && option.calls.length > 0) {
                callOption = option.calls[0];
            } 
            // Fallback to the 'call' property if it exists (for backwards compatibility)
            else if (option.call) {
                callOption = option.call;
            }
            
            // Extract the first put option from the puts array if it exists
            if (option.puts && option.puts.length > 0) {
                putOption = option.puts[0];
            } 
            // Fallback to the 'put' property if it exists (for backwards compatibility)
            else if (option.put) {
                putOption = option.put;
            }
            
            // Process call option if available
            if (callOption) {
                // Show the raw bid/ask values with more decimal places to see if they're very small but non-zero
                const callBid = callOption.bid !== undefined ? callOption.bid : 'undefined';
                const callAsk = callOption.ask !== undefined ? callOption.ask : 'undefined';
                
                // Check for very small values that might be treated as zero
                const hasSmallBidAsk = (callBid > 0 && callBid < 0.01) || (callAsk > 0 && callAsk < 0.01);
                
                console.log(`Call raw values for ${ticker}: bid=${callBid.toFixed(6)}, ask=${callAsk.toFixed(6)}, hasSmallValues=${hasSmallBidAsk}`);
                
                callContent = formatStrike(callOption.strike) + (callOption.delta ? ` (δ=${callOption.delta.toFixed(2)})` : '');
                
                // Log call earnings data
                console.log(`Call earnings for ${ticker}:`, callOption.earnings);
                
                if (callOption.earnings) {
                    const e = callOption.earnings;
                    
                    // Show raw premium value with more decimal places
                    const rawPremium = e.premium_per_contract !== undefined ? e.premium_per_contract : 'undefined';
                    console.log(`Call premium raw value for ${ticker}: ${rawPremium.toFixed(6)}`);
                    
                    // Check if we actually have valid premium values
                    if (e.premium_per_contract > 0 && e.total_premium > 0) {
                        callPremium = `${e.max_contracts} × ${formatCurrency(e.premium_per_contract)} = ${formatCurrency(e.total_premium)} (${e.return_on_capital.toFixed(2)}%)`;
                    } else {
                        // Show exact bid/ask values with more decimal places
                        callPremium = `<span class="text-muted">No premium available</span><br>
                            <small class="text-muted">Bid: ${callBid.toFixed(6)}, Ask: ${callAsk.toFixed(6)}</small>
                            ${hasSmallBidAsk ? '<br><small class="text-warning">⚠️ Very small values detected</small>' : ''}`;
                    }
                } else {
                    callPremium = `<span class="text-muted">No earnings data available</span><br>
                        <small class="text-muted">Bid: ${callBid.toFixed(6)}, Ask: ${callAsk.toFixed(6)}</small>
                        ${hasSmallBidAsk ? '<br><small class="text-warning">⚠️ Very small values detected</small>' : ''}`;
                }
            }
            
            // Process put option if available
            if (putOption) {
                // Show the raw bid/ask values with more decimal places to see if they're very small but non-zero
                const putBid = putOption.bid !== undefined ? putOption.bid : 'undefined';
                const putAsk = putOption.ask !== undefined ? putOption.ask : 'undefined';
                
                // Check for very small values that might be treated as zero
                const hasSmallBidAsk = (putBid > 0 && putBid < 0.01) || (putAsk > 0 && putAsk < 0.01);
                
                console.log(`Put raw values for ${ticker}: bid=${putBid.toFixed(6)}, ask=${putAsk.toFixed(6)}, hasSmallValues=${hasSmallBidAsk}`);
                
                putContent = formatStrike(putOption.strike) + (putOption.delta ? ` (δ=${putOption.delta.toFixed(2)})` : '');
                
                // Log put earnings data
                console.log(`Put earnings for ${ticker}:`, putOption.earnings);
                
                if (putOption.earnings) {
                    const e = putOption.earnings;
                    
                    // Show raw premium value with more decimal places
                    const rawPremium = e.premium_per_contract !== undefined ? e.premium_per_contract : 'undefined';
                    console.log(`Put premium raw value for ${ticker}: ${rawPremium.toFixed(6)}`);
                    
                    // Check if we actually have valid premium values
                    if (e.premium_per_contract > 0 && e.total_premium > 0) {
                        putPremium = `${e.max_contracts} × ${formatCurrency(e.premium_per_contract)} = ${formatCurrency(e.total_premium)} (${e.return_on_cash.toFixed(2)}%)`;
                    } else {
                        // Show exact bid/ask values with more decimal places
                        putPremium = `<span class="text-muted">No premium available</span><br>
                            <small class="text-muted">Bid: ${putBid.toFixed(6)}, Ask: ${putAsk.toFixed(6)}</small>
                            ${hasSmallBidAsk ? '<br><small class="text-warning">⚠️ Very small values detected</small>' : ''}`;
                    }
                } else {
                    putPremium = `<span class="text-muted">No earnings data available</span><br>
                        <small class="text-muted">Bid: ${putBid.toFixed(6)}, Ask: ${putAsk.toFixed(6)}</small>
                        ${hasSmallBidAsk ? '<br><small class="text-warning">⚠️ Very small values detected</small>' : ''}`;
                }
            }
            
            // Show expiration date from the data
            const expirationDate = data.expiration ? new Date(data.expiration) : null;
            const expirationText = expirationDate ? 
                `<small class="text-muted">Exp: ${formatDate(expirationDate)}</small>` : 
                '';
            
            // Format the last updated time
            const now = new Date();
            const lastUpdated = tickersData[ticker].lastUpdated || now;
            const timeDiff = Math.round((now - lastUpdated) / 1000);
            const lastUpdatedText = `<small class="text-success">Real-time data as of ${lastUpdated.toLocaleTimeString()}</small>`;
            
            // Update the cells with extra information
            tdElements[4].innerHTML = `${callContent}<br>${expirationText}<br>${lastUpdatedText}`;
            tdElements[5].innerHTML = callPremium;
            tdElements[6].innerHTML = `${putContent}<br>${expirationText}`;
            tdElements[7].innerHTML = putPremium;
            
            // Add OTM information
            const otmInfo = document.createElement('div');
            otmInfo.className = 'mt-2';
            otmInfo.innerHTML = `<small class="text-muted">Using OTM: ${data.otm_percentage}%</small>`;
            
            // Add a data refresh button after options are loaded
            const refreshBtn = document.createElement('button');
            refreshBtn.className = 'btn btn-sm btn-outline-primary fetch-btn mt-2 me-2';
            refreshBtn.setAttribute('data-ticker', ticker);
            refreshBtn.innerHTML = `<i class="bi bi-arrow-repeat"></i> Refresh Data`;
            refreshBtn.addEventListener('click', function() {
                fetchOptionsForTicker(ticker);
            });
            
            // Add order button for this ticker
            const orderBtn = document.createElement('button');
            orderBtn.className = 'btn btn-sm btn-outline-success order-btn mt-2';
            orderBtn.setAttribute('data-ticker', ticker);
            orderBtn.innerHTML = `<i class="bi bi-plus-circle"></i> Order`;
            orderBtn.addEventListener('click', function() {
                orderOptionsForTicker(ticker);
            });
            
            // Add the OTM info to the Sell Call cell and the refresh button to the Actions cell (last column)
            const actionBtnContainer = document.createElement('div');
            actionBtnContainer.className = 'mt-2 d-flex gap-2';
            actionBtnContainer.appendChild(refreshBtn);
            actionBtnContainer.appendChild(orderBtn);
            
            // Add OTM info to the Sell Call cell if not already present
            if (tdElements[4].querySelector('.text-muted') === null) {
                tdElements[4].appendChild(otmInfo);
            }
            
            // Add refresh button to the Actions column (last column - index 8)
            if (tdElements[8] && tdElements[8].querySelector('.fetch-btn') === null) {
                tdElements[8].appendChild(actionBtnContainer);
            }
        }
        
        // Refresh all tickers
        function refreshAllOptions() {
            const tickers = Object.keys(tickersData);
            if (tickers.length === 0) return;
            
            // Process each ticker with a small delay
            tickers.forEach((ticker, index) => {
                setTimeout(() => {
                    fetchOptionsForTicker(ticker);
                }, index * 1000); // 1 second delay between each
            });
        }
        
        // Add event listeners after tickers are loaded
        function setupEventListeners() {
            try {
                // Add event listeners to all OTM sliders
                document.querySelectorAll('.otm-slider').forEach(slider => {
                    slider.addEventListener('input', function() {
                        const ticker = this.getAttribute('data-ticker');
                        const value = this.value;
                        
                        if (ticker && tickersData[ticker]) {
                            // Update display and store state
                            const valueElement = document.getElementById(`otm-value-${ticker}`);
                            if (valueElement) {
                                valueElement.textContent = `${value}%`;
                            }
                            tickersData[ticker].otmPercentage = parseInt(value);
                            console.log(`Updated OTM for ${ticker} to ${value}%`);
                        }
                    });
                });
                
                // Add event listeners to all fetch buttons
                document.querySelectorAll('.fetch-btn').forEach(button => {
                    button.addEventListener('click', function() {
                        const ticker = this.getAttribute('data-ticker');
                        if (ticker) {
                            console.log(`Fetch button clicked for ${ticker}`);
                            fetchOptionsForTicker(ticker);
                        } else {
                            console.error('Fetch button clicked but no ticker attribute found');
                        }
                    });
                });
                
                // Add refresh all button handler
                const refreshAllBtn = document.getElementById('refresh-all-options');
                if (refreshAllBtn) {
                    refreshAllBtn.addEventListener('click', function() {
                        console.log('Refresh all button clicked');
                        refreshAllOptions();
                    });
                }
                
                // Add order button handler
                const orderBtn = document.getElementById('order-selected-option');
                if (orderBtn) {
                    orderBtn.addEventListener('click', function() {
                        console.log('Order button clicked');
                        placeOrder();
                    });
                }
                
                // Add refresh pending orders button handler
                const refreshPendingBtn = document.getElementById('refresh-pending-orders');
                if (refreshPendingBtn) {
                    refreshPendingBtn.addEventListener('click', function() {
                        console.log('Refresh pending orders button clicked');
                        loadPendingOrders();
                    });
                }
                
                // Add Order All handler
                const orderAllBtn = document.getElementById('order-all-options');
                if (orderAllBtn) {
                    orderAllBtn.addEventListener('click', function() {
                        console.log('Order all button clicked');
                        orderAllOptions();
                    });
                }
                
                console.log('All event listeners set up successfully');
            } catch (error) {
                console.error('Error setting up event listeners:', error);
            }
        }
        
        // Fetch tickers and initialize the options table
        function fetchTickers() {
            const optionsTable = document.getElementById('options-table');
            if (!optionsTable) {
                console.error('Options table not found');
                return;
            }
            
            optionsTable.innerHTML = '<tr><td colspan="9" class="text-center">Loading tickers...</td></tr>';
            
            fetch('/api/portfolio/positions')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    optionsTable.innerHTML = '';
                    
                    if (!data || data.length === 0) {
                        optionsTable.innerHTML = '<tr><td colspan="9" class="text-center">No tickers found</td></tr>';
                        return;
                    }
                    
                    console.log('Loaded tickers data:', data);
                    
                    // Sort positions by market value (descending)
                    data.sort((a, b) => b.market_value - a.market_value);
                    
                    // Create a row for each ticker with OTM slider
                    data.forEach(position => {
                        const ticker = position.symbol;
                        
                        // Store ticker info in our state object with default OTM of 10%
                        tickersData[ticker] = {
                            otmPercentage: 10,
                            price: position.market_price,
                            position: position.position,
                            data: null,
                            isLoading: false
                        };
                        
                        const row = document.createElement('tr');
                        row.id = `ticker-row-${ticker}`;
                        
                        // Ensure we're adding 9 cells to each row (9 columns in the table)
                        row.innerHTML = `
                            <td><strong>${ticker}</strong></td>
                            <td>${formatCurrency(position.market_price)}</td>
                            <td>${position.position}</td>
                            <td>
                                <div class="input-group input-group-sm" style="width: 120px;">
                                    <input type="range" class="form-range otm-slider" id="otm-${ticker}" 
                                           min="5" max="30" step="5" value="10" 
                                           data-ticker="${ticker}">
                                    <span class="input-group-text" id="otm-value-${ticker}">10%</span>
                                </div>
                            </td>
                            <td><!-- Sell Call --></td>
                            <td><!-- Call Premium --></td>
                            <td><!-- Sell Put --></td>
                            <td><!-- Put Premium --></td>
                            <td><!-- Actions - will be filled with Refresh Data button later --></td>
                        `;
                        
                        // Add row to the table
                        optionsTable.appendChild(row);
                        
                        // Now place the fetch button in the Sell Call column (5th column, index 4)
                        const tdElements = row.querySelectorAll('td');
                        if (tdElements.length >= 5) {
                            const fetchBtn = document.createElement('button');
                            fetchBtn.className = 'btn btn-sm btn-primary fetch-btn';
                            fetchBtn.setAttribute('data-ticker', ticker);
                            fetchBtn.textContent = 'Fetch Options';
                            tdElements[4].innerHTML = '';
                            tdElements[4].appendChild(fetchBtn);
                        }
                    });
                    
                    console.log('Ticker rows created, setting up event listeners');
                    // Set up event listeners
                    setupEventListeners();
                    
                    // Verify table structure
                    document.querySelectorAll('#options-table tr').forEach(row => {
                        const cells = row.querySelectorAll('td');
                        console.log(`Row ${row.id} has ${cells.length} cells`);
                    });
                    
                    // Load first ticker automatically
                    if (Object.keys(tickersData).length > 0) {
                        console.log('Auto-loading first ticker');
                        const firstTicker = Object.keys(tickersData)[0];
                        setTimeout(() => {
                            fetchOptionsForTicker(firstTicker);
                        }, 500);
                    }
                })
                .catch(error => {
                    console.error('Error fetching tickers:', error);
                    optionsTable.innerHTML = '<tr><td colspan="9" class="text-center text-danger">Error loading tickers</td></tr>';
                });
        }
        
        // Test API connection with real-time data
        function testApiEndpoint() {
            console.log('Testing real-time API endpoint...');
            const timestamp = new Date().getTime();
            fetch(`/api/options/otm?tickers=AAPL&otm=10&real_time=true&options_only=true&t=${timestamp}`, {
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            })
            .then(response => {
                console.log('Real-time API test response status:', response.status);
                if (!response.ok) {
                    console.error('Real-time API test failed with status:', response.status);
                    return;
                }
                console.log('Real-time API test successful!');
                return response.json();
            })
            .then(data => {
                if (data) {
                    console.log('Sample real-time data received:', data);
                    // Check for the presence of bid/ask values
                    if (data.data && data.data.AAPL) {
                        const appleData = data.data.AAPL;
                        
                        // Try to extract call data from either 'call' property or first item in 'calls' array
                        let callOption = null;
                        if (appleData.calls && appleData.calls.length > 0) {
                            callOption = appleData.calls[0];
                            console.log('AAPL call found in calls array:', callOption);
                        } else if (appleData.call) {
                            callOption = appleData.call;
                            console.log('AAPL call found in call property:', callOption);
                        }
                        
                        if (callOption) {
                            console.log('AAPL call bid/ask:', callOption.bid, callOption.ask);
                        } else {
                            console.log('No call option data found for AAPL');
                        }
                    }
                }
            })
            .catch(error => {
                console.error('Real-time API test error:', error);
            });
        }
        
        // Function to order options for a specific ticker
        function orderOptionsForTicker(ticker) {
            if (!ticker || !tickersData[ticker] || !tickersData[ticker].data || !tickersData[ticker].data.data || !tickersData[ticker].data.data[ticker]) {
                console.error(`No option data available for ${ticker}`);
                alert(`No option data available for ${ticker}. Please refresh data first.`);
                return;
            }
            
            const optionData = tickersData[ticker].data.data[ticker];
            console.log(`Ordering options for ${ticker}:`, optionData);
            
            // Prepare the order data for call option
            let callOption = null;
            if (optionData.calls && optionData.calls.length > 0) {
                callOption = optionData.calls[0];
            } else if (optionData.call) {
                callOption = optionData.call;
            }
            
            // Prepare the order data for put option
            let putOption = null;
            if (optionData.puts && optionData.puts.length > 0) {
                putOption = optionData.puts[0];
            } else if (optionData.put) {
                putOption = optionData.put;
            }
            
            // Check if we have valid options
            if (!callOption && !putOption) {
                console.error(`No call or put options available for ${ticker}`);
                alert(`No valid options available for ${ticker}. Please refresh data first.`);
                return;
            }
            
            // Save the call option order
            if (callOption) {
                const callOrderData = {
                    ticker: ticker,
                    option_type: 'CALL',
                    strike: callOption.strike,
                    expiration: callOption.expiration,
                    premium: callOption.ask || 0,
                    details: JSON.stringify(callOption)
                };
                
                // Save the call order
                saveOptionOrder(callOrderData);
            }
            
            // Save the put option order
            if (putOption) {
                const putOrderData = {
                    ticker: ticker,
                    option_type: 'PUT',
                    strike: putOption.strike,
                    expiration: putOption.expiration,
                    premium: putOption.ask || 0,
                    details: JSON.stringify(putOption)
                };
                
                // Save the put order
                saveOptionOrder(putOrderData);
            }
        }
        
        // Function to order all available options
        function orderAllOptions() {
            const tickers = Object.keys(tickersData);
            if (tickers.length === 0) {
                alert('No option data available. Please refresh data first.');
                return;
            }
            
            let orderCount = 0;
            
            // Process each ticker
            tickers.forEach(ticker => {
                if (tickersData[ticker] && tickersData[ticker].data && tickersData[ticker].data.data && tickersData[ticker].data.data[ticker]) {
                    orderOptionsForTicker(ticker);
                    orderCount++;
                }
            });
            
            alert(`Ordered options for ${orderCount} tickers.`);
            
            // Reload the pending orders table
            loadPendingOrders();
        }
        
        // Function to save an option order to the database
        function saveOptionOrder(orderData) {
            console.log('Saving order:', orderData);
            
            fetch('/api/options/order', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(orderData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Order saved successfully:', data);
                // Reload the pending orders table
                loadPendingOrders();
            })
            .catch(error => {
                console.error('Error saving order:', error);
                alert(`Error saving order: ${error.message}`);
            });
        }
        
        // Initialize all dashboard components
        try {
            console.log('Initializing dashboard...');
            loadPortfolioData();
            loadPositionsTable();
            fetchTickers();
            loadPendingOrders();  // Load pending orders on startup
            
            // Test API endpoints
            setTimeout(testApiEndpoint, 1000);
        } catch (error) {
            console.error('Error initializing dashboard:', error);
        }
    });
</script>
{% endblock %} 